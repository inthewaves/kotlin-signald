// File is generated by ./gradlew generateSignaldClasses --- do not edit unless reformatting
package org.inthewaves.kotlinsignald.clientprotocol.v1.structures

import kotlinx.serialization.KSerializer
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import org.inthewaves.kotlinsignald.clientprotocol.SocketCommunicator
import org.inthewaves.kotlinsignald.clientprotocol.SuspendSocketCommunicator
import org.inthewaves.kotlinsignald.clientprotocol.v1.requests.FinishLink
import org.inthewaves.kotlinsignald.clientprotocol.v1.requests.JsonMessageWrapper

/**
 * After a linking URI has been requested, finish_link must be called with the session_id provided
 * with the URI. it will return information about the new account once the linking process is completed
 * by the other device and the new account is setup. Note that the account setup process can sometimes
 * take some time, if rapid userfeedback is required after scanning, use wait_for_scan first, then
 * finish setup with finish_link.
 */
@Serializable
@SerialName("finish_link")
public data class FinishLinkRequest(
    /**
     * overwrite existing account data if the phone number conflicts. false by default
     */
    public val overwrite: Boolean? = null,
    @SerialName("device_name")
    public val deviceName: String? = null,
    @SerialName("session_id")
    public val sessionId: String? = null
) : SignaldRequestBodyV1<Account>() {
    internal override val responseWrapperSerializer: KSerializer<FinishLink>
        get() = FinishLink.serializer()

    internal override val responseDataSerializer: KSerializer<Account>
        get() = Account.serializer()

    internal override fun getTypedResponseOrNull(responseWrapper: JsonMessageWrapper<*>): Account? =
        if (responseWrapper is FinishLink && responseWrapper.data is Account) {
            responseWrapper.data
        } else {
            null
        }

    /**
     * @throws org.inthewaves.kotlinsignald.clientprotocol.RequestFailedException if the signald
     * socket sends a bad or error response, or unable to serialize our request
     * @throws org.inthewaves.kotlinsignald.clientprotocol.SignaldException if an I/O error occurs
     * during socket communication
     * @throws NoSuchSessionError
     * @throws ServerNotFoundError
     * @throws InvalidProxyError
     * @throws InternalError
     * @throws NoSuchAccountError
     * @throws UserAlreadyExistsError
     * @throws ScanTimeoutError
     */
    public override fun submit(socketCommunicator: SocketCommunicator, id: String): Account =
        super.submit(socketCommunicator, id)

    /**
     * @throws org.inthewaves.kotlinsignald.clientprotocol.RequestFailedException if the signald
     * socket sends a bad or error response, or unable to serialize our request
     * @throws org.inthewaves.kotlinsignald.clientprotocol.SignaldException if an I/O error occurs
     * during socket communication
     * @throws NoSuchSessionError
     * @throws ServerNotFoundError
     * @throws InvalidProxyError
     * @throws InternalError
     * @throws NoSuchAccountError
     * @throws UserAlreadyExistsError
     * @throws ScanTimeoutError
     */
    public override suspend fun submitSuspend(
        socketCommunicator: SuspendSocketCommunicator,
        id: String
    ): Account = super.submitSuspend(socketCommunicator, id)
}

// File is generated by ./gradlew generateSignaldClasses --- do not edit unless reformatting
package org.inthewaves.kotlinsignald.clientprotocol.v1.structures

import kotlinx.serialization.Serializable
import kotlinx.serialization.SerializationException
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.booleanOrNull
import org.inthewaves.kotlinsignald.clientprotocol.SignaldJson

/**
 * Wraps all incoming messages sent to the client after a v1 subscribe request is issued
 *
 * Note that the `type` field has been removed. kotlinx.serialization uses that as a discriminator
 */
@Serializable
public sealed class ClientMessageWrapper {
    /**
     * the version of the object in the `data` field
     */
    public abstract val version: String?

    /**
     * the incoming object. The structure will vary from message to message, see `type` and
     * `version` fields
     */
    public abstract val data: Data

    /**
     * true if the incoming message represents an error
     */
    public abstract val error: Boolean?

    /**
     * the account this message is from
     */
    public abstract val account: String?

    @Serializable
    public sealed class Data

    public companion object {
        /**
         * @throws [SerializationException] if deserialization fails
         */
        @Throws(SerializationException::class)
        public fun decodeFromStringOrThrow(incomingMessageString: String): ClientMessageWrapper =
            try {
                SignaldJson.decodeFromString(serializer(), incomingMessageString)
            } catch (e: SerializationException) {
                // Try to polymorphically deserialize the error.
                val responseJson: JsonObject = try {
                    SignaldJson.decodeFromString(JsonObject.serializer(), incomingMessageString)
                } catch (anotherException: SerializationException) {
                    e.addSuppressed(anotherException)
                    throw SerializationException("incoming object is not a valid JSON object", e)
                }
                val isError = (responseJson["error"] as? JsonPrimitive)?.booleanOrNull ?: false
                if (!isError) {
                    throw SerializationException("incoming object is an unrecognized non-error type", e)
                }
                val errorType = (responseJson["type"] as? JsonPrimitive)
                    ?.takeIf { it.isString }
                    ?.content
                    ?: throw SerializationException("incoming object has no type", e)
                val errorData = responseJson["data"] as? JsonObject
                    ?: throw SerializationException("data is not a JSON object", e)
                val deserializer = SignaldJson.serializersModule.getPolymorphic(
                    TypedExceptionV1::class,
                    errorType
                )
                    ?: throw SerializationException("""$errorType is an unrecognized error type""", e)

                val exceptionType: TypedExceptionV1 = try {
                    SignaldJson.decodeFromJsonElement(deserializer, errorData)
                } catch (anotherException: SerializationException) {
                    e.addSuppressed(anotherException)
                    throw SerializationException("""body for $errorType has invalid schema""", e)
                }

                IncomingException(
                    version = (responseJson["version"] as? JsonPrimitive)
                        ?.takeIf { it.isString }
                        ?.content,
                    data = IncomingException.Data(typedException = exceptionType),
                    error = true,
                    account = (responseJson["account"] as? JsonPrimitive)
                        ?.takeIf { it.isString }
                        ?.content
                )
            }
    }
}
